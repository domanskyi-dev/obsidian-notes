### Переменные и ввод/вывод данных

**Переменная** — это именованная область памяти компьютера, адрес которой позволяет получить доступ к данным.

Запись данных в переменную (**оператор присваивания**):
```python
some_string = "value"
```

Существует два главных **правила именования переменных:**
- Название переменной должно состоять только из букв, цифр и знаков подчеркивания `_`.
- Название переменной не должно начинаться с цифры.
- PEP8

**множественное присваивание :**
```python
a, b = "some_string_a", "some_string_b"
```

**Функция** — фрагмент кода, к которому можно обратиться из любого другого места.

Код, облаченный в функцию, выполняет **алгоритм**, который, как правило, является целостным и преследует конкретную цель. **Цель алгоритма может быть двух видов:**
просто выполнить определенный набор команд или подготовить(вернуть) некоторый результат (данные).

**Аргументы** — это данные, которые необходимы функции для работы.

#### **Ввод с консоли, input()**
Функция `input()` _всегда возвращает данные в виде текста,_ даже если введено число.

#### **Вывод в консоль, print()**
Функция **`print()`**. Она предназначена показывать в консоли всё, что находится в круглых скобках после слова `print(аргумент функции)`.
```python
print("Ответ на главный вопрос жизни, вселенной и всего такого -", 42)
# Ответ на главный вопрос жизни, вселенной и всего такого - 42
```

## **Типы данных**

| **Данные**               | **Типы** | **Примеры**          |
| ------------------------ | -------- | -------------------- |
| Целые числа              | `int`    | 73, 0                |
| Числа с плавающей точкой | `float`  | 3.14, -2.79          |
| Строки                   | `str`    | `"Hello, world!"`    |
| Логические переменные    | `bool`   | `True, False`        |
| Списки                   | `list`   | `[1,2,3,4]`          |
| Кортежи                  | `tuple`  | `(‘a’,’b’,’c’)`      |
| Словари                  | `dict`   | `{‘a’ : 1, ‘b’ : 2}` |
| Множества                | `set`    | `{‘a’, 1, ‘b’, 2}`   |
_Python_ — _язык с неявной сильной динамической типизацией_.

**Динамическая типизация** означает, что тип переменной определяется во время выполнения программы, а не во время компиляции. Поэтому справедливо говорить, что переменная — это контейнер. Во время выполнения программы в него можно положить данные одного типа, после чего заменить данными другого типа.

**Сильная типизация** нам говорит о том, что мы не можем совершать операции над объектами разного типа без приведения их к одному типу. Например, _Python_ вызовет ошибку, если мы попытаемся сложить число и строку.

**Неявная типизация** нам говорит о том, что тип переменной при её объявлении не нужно указывать.

_Python_ позволяют узнавать тип переменной, используя встроенную функцию **`type()`**:
```python
a = 3.14
b = '3.14'

print(type(a))
# <class 'float'>
print(type(b))
# <class 'str'>
```

Все типы можно разделить на две группы: **изменяемые** и **неизменяемые** типы данных.

| **Неизменяемые типы**            | **Изменяемые типы** |
| -------------------------------- | ------------------- |
| Целые числа (int)                | Списки (list)       |
| Числа с плавающей точкой (float) | Словари (dict)      |
| Строки (str)                     | Множества (set)     |
| Логические переменные (bool)     |                     |
| Кортежи (tuple)                  |                     |
Особенность _неизменяемых типов_ заключается в том, что такие объекты не могут быть изменены «на лету».
Если вы захотите произвести операцию, например, со строкой, то будет создана новая строка с теми изменениями, которые вы собираетесь внести. Однако это не касается списков, словарей и множеств, в которые вы можете добавлять новые элементы, удалять старые или обновлять существующие — сам объект останется прежним.

## **Неизменяемые типы данных**
### **Целые числа**
Объекты типа **`int`** предназначены для хранения целочисленных данных. Создание такой переменной не требует особой записи — необходимо только присвоить целое число этой переменной.
С такими объектами можно производить известные **операции**: сложение, вычитание, умножение и возведение в степень. В результате получаются также целые числа (кроме операции деления)

Посмотрим, как будут вести себя целые числа при использовании «обычного» деления:
```python
a = 5/2
print(a)
# 2.5
```
Как можем видеть, результатом такого деления стало число с плавающей точкой. Для получения целого числа как результата деления используется две специфические операции — **целочисленное деление** и **взятие остатка от деления.**

Операция целочисленного деления **`//`** возвращает целую часть получившегося результата, отбрасывая всю дробную часть. Приведем несколько примеров:
```python
print(1 // 3)
# 0
print(3 // 3)
# 1
print(29 // 3)
# 9
```
О величине самой дробной части или, если быть точным, об **остатке от деления**, можно судить по результату операции **`%`.** Остаток от деления показывает, на сколько делимое больше ближайшего числа, которое делится нацело:
```python
print(1 % 3) # ближайшее число, которое нацело делится на 3 - это ноль
# 1
print(3 % 3) # в этом примере сам делитель может нацело разделиться
# 0
print(29 % 3) # здесь ближайшее число - 27, и поэтому результат 29-27=2
# 2
```

| **Операция**          | **Обозначение** | **Пример**   |
| --------------------- | --------------- | ------------ |
| Сложение              | +               | 7+5 = 12     |
| Разность              | -               | 7-5 = 2      |
| Умножение             | *               | 7*5 = 35     |
| Возведение в степень  | **              | 7**5 = 16807 |
| Целочисленное деление | //              | 7 // 5 = 1   |
| Остаток от деления    | %               | 7 % 5 = 2    |
Если приоритеты не регулируются скобками, то арифметические операции будут выполняться **в следующем порядке**:
- Возведение в степень;
- Умножение, целочисленное деление и остаток от деления;
- Сложение и вычитание.

Отдельно отметим особенность операций целочисленного деления и нахождения остатка от деления **в случае отрицательных чисел**.

Общее правило, по которому находится частное и остаток, можно сформулировать следующим образом. Если `a` — делимое, `b` — делитель, `q` — частное, а `r` — остаток, то:
1. `q, r` определяются из формулы: `a = b*q+r.`
2. `r — число между 0 и b (не включая b). То есть, если b положительно, то 0 ≤ r < b. Если b отрицательно, то b < r ≤ 0`
```python
a = 5
b = 2
q = a // b # q = 2
r = a % b  # r = 1
```
Получили результат, согласующийся с формулой: максимально близкое число, на которое можно разделить нацело — это 2, и остаток в таком случае равен 1.

```python
a = 5
b = -2
q = a // b # в данном случае q = -3
r = a % b # а остаток r = -1
```
Дело в том, что максимальное число, которое можно нацело разделить на число -2 — это 6. При его делении на -2 получаем -3 и соответствующий остаток, равный -1.
###### **Длинная арифметика**
Одна из особенностей целых чисел в _Python_ заключается в том, что их точность бесконечна. Иными словами, в целочисленную переменную вы можете записать сколь угодно большие числа, и даже производить операции с ними без какой-либо потери точности.
Естественно, время вычисления такой сложной операции будет не маленьким, но такая возможность есть. Она отличает _Python_ от многих других языков, в которых нет встроенной поддержки **длинной арифметики**.
### **Числа с плавающей точкой**
Под числами с плавающей точкой подразумеваются **дробные числа**, а сам термин «плавающая точка» или «плавающая запятая» происходит от особенностей хранения таких чисел в памяти компьютера.
Создание переменных с дробными числами практически ничем не отличается от создания целых чисел. Разве что нужно помнить, что в качестве десятичного разделителя выступает **точка**
С числами с плавающей точкой можно производить уже **все знакомые операции**, в том числе и деление.

Общеприняты две записи чисел с плавающей точкой — в _десятичной форме_ и в _экспоненциальной_.
**Десятичная форма** нам привычна — сначала записывается целая часть, десятичный разделитель и за ним дробная часть.

В результате некоторых операций может случиться так, что число становится очень большим (или очень маленьким), и его трудно представить в десятичном виде. В таком случае на помощь приходит **экспоненциальная форма** записи числа:
```python
print(a**100)
# 3.138886636534116e+73
```
Такую запись можно интерпретировать следующим образом. Слева от буквы `e` находится **мантисса**. Это обычное дробное число, для которого есть соглашение о том, что оно больше 1 и меньше 10. Справа от буквы `e` записан порядок числа. Иными словами, это степень числа 10. В таком случае это число можно прочитать как: "3.138886636534116 умножить на 10 в степени 73".
В памяти компьютера мантисса («само» число, его значащие цифры) хранятся отдельно, а показатель степени числа — отдельно. Благодаря этому, умножение на степени числа 10 **никак** не влияет на мантиссу, прибавляя (или вычитая, в случае деления) соответствующую степень десятки к показателю степени множителя.

| **Операция**         | **Обозначение** | **Пример**       |
| -------------------- | --------------- | ---------------- |
| Сложение             | `+`             | 3.14+1 = 4.14    |
| Вычитание            | `-`             | 3.14-1 = 2.14    |
| Умножение            | `*`             | 3.14*2 = 6.28    |
| Возведение в степень | `**`            | 3.14**2 = 9.8596 |
| Деление              | `/`             | 3.14/2 = 1.57    |
Числа с плавающей точкой в отличие от целых чисел _не обладают бесконечной точностью._ Это обусловлено способом их хранения и выполнения операций над ними.
```python
print(1/3)
# 0.3333333333333333
```
Казалось бы, всё хорошо, как и ожидалось. В результате такого деления мы получаем десятичную дробь с бесконечным количеством цифр 3 после запятой. Попросим _Python_ вычислить другое выражение:
```python
print(1.3+2.3)
# 3.5999999999999996
```
И здесь мы ясно видим, что после 16 знака после запятой вычисления дают сбой, который является естественным для _Python_. Ответ кроется в том, что для хранения числа используется ограниченное количество памяти (в байтах), которых хватает только на то, чтобы корректно вычислить 16 знаков. Для обхода этой проблемы, если необходимо использовать более точные вычисления, могут использоваться классы **`Fraction`** и **`Decimal`**.
[[Модуль fractions]]
[[Модуль decimal]]
### **Строки**
**Строки** — это неизменяемый тип данных, предназначенный для хранения текстовой информации.

Для представления текстовой информации в _Python_ используются объекты типа **`str`** — **строки**. Запись текстовых данных осуществляется с помощью апострофов и кавычек:
```python
some_text = "python"
other_text = 'Java'

introducing = "I'm Ivan"
action = 'Я читаю "Изучаем python" Марка Лутца'

long_text = '''Здесь может
               находиться
               большой "кусок" кода'''
other_long_text = """Таким образом тоже
                     можно записать"""
```
_Python_ позволяет получить доступ к отдельным символам или даже подстрокам, обращаясь к ним по индексам — порядковому номеру символа в строке:
```python
s = "python"
print(s[0])
# p
print(s[1:4])
# yth
```
Несмотря на то, что мы можем прочитать отдельный символ, перезаписать мы его не можем, потому что строки являются **неизменяемыми данными**:
```python
s = "python"
s[0] = 'C'
print(s)
# ожидается вывод "Cython", однако python вернет ошибку:
# TypeError: 'str' object does not support item assignment
```

##### Срез:
```python
print(s[1:4])
# ell
```
Выражение, находящееся внутри квадратных скобок, называется срезом.

**Срез** — это подмножество элементов итерируемого объекта, которое задаётся следующим образом:
`mystr[START:STOP:STEP]` — берёт срез от номера START до STOP, **не включая его**, с шагом STEP. По умолчанию START=0, STOP=длина объекта, STEP=1.

Рассмотрим несколько примеров. Все значения заданы по умолчанию.
- Идём от первого до последнего элемента с шагом 1.
```python
mystr[::] # Вывод программы будет таким: 'Hello world!'
```
- Хотим начать со второго индекса.
```python
mystr[2::] # Вывод программы будет таким: 'llo world!'
```
- Хотим пойти с шагом через 1.
```python
mystr[::2] # Вывод программы будет таким: 'Hlowrd'
```
У срезов есть ещё одна интересная возможность — идти не от начала, а от конца, добавив знак "-".
- Хотим начать от последнего элемента.
```python
mystr[-1] # Вывод программы будет таким: '!'
```
- Хотим вывести все элементы кроме двух последних.
```python
mystr[:-2] # Вывод программы будет таким: 'Hello worl'
```
- Хотим вывести элементы не с шагом 1, а в обратном порядке с шагом -1.
```python
mystr[::-1] # Вывод программы будет таким: '!dlrow olleH'
```

##### **Полезные функции**
- Встроенная функция **`len()`** позволяет узнать длину строки:
```python
print(len(s)) # 6
```
- Метод **`find(substr)`**, определенный для строк, позволяет находить символы и подстроки:
```python
print(s.find('e')) # возвращает индекс
# 1

print(s.find('o!')) # в случае подстроки возвращает индекс первого символа
# 4
```
Если символ или подстрока встречаются несколько раз, то возвращается индекс первого вхождения:
```python
print(s.find('l')) # встречается в индексах 2 и 3
# 2
```
- Ряд функций позволяет определить, состоит ли строка из цифр, букв или одновременно из букв и цифр:
```python
print(s.isdigit()) # строка состоит из цифр?
# False

print(s.isalpha()) # строка состоит из букв?
# False

print(s.isalnum()) # строка состоит из цифр и букв?
# False
```
- Приведенные ниже методы позволяют привести все буквы к верхнему регистру (заглавным буквам) или к нижнему регистру (строчным буквам). Обратите внимание, что исходная строка **не изменяется**:
```python
print(s.upper())
# HELLO!

print(s.lower())
# hello!

print(s)
# Hello!
```
[Строки. Функции и методы строк](https://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html)

### **Логические переменные**
Чтобы иметь определенность в создании таких объектов, по смыслу соответствующих «истина» и «ложь», в _Python_ существует тип логических переменных — **`bool`**. Их еще называют булевыми переменными. Они создаются с помощью ключевых слов `True` и `False`, как некоторая договоренность между разработчиками для именования таких значений:
```python
t = True
f = False
```
Логические значения можно получать и как возвращаемое значение некоторых действий, таких как сравнение:
```python
print(3 > 10)
# False

print(3 < 10)
# True

print(3 == 10) # равны ли объекты?
# False
```
Можно также проверить, содержится ли какой-то символ в строке:
```python
print('r' in 'world') # проверяем отдельный символ
# True

print('th' in 'python') # проверяем целую подстроку
# True

print('the' in 'python')
# False
```
По своему смыслу логические значения остаются эквивалентны **нулю** (`False`) и **единице** (`True`).

### **Кортеж**
Для сохранения нескольких объектов (необязательно текстовых) в одну переменную можно использовать **кортежи** (**`tuple`**). Чтобы создать кортеж, нужно записать данные в круглые скобки через запятую:
```python
date = (1, 'january', 2020)
```
После чего можно получить доступ к отдельным переменным по индексу:
```python
print(date[0])
# 1
print(date[1])
# january
print(date[2])
# 2020
```
В связи с тем, что кортеж, также как и другие приведенные выше типы, является неизменяемым, попытка его модифицировать приведёт к ошибке:
```python
date[0] = date[0] + 1
# TypeError: 'tuple' object does not support item assignment
```

### **Снова про неизменяемость**
Когда мы кратко познакомились с основными неизменяемыми типами данных, ещё раз посмотрим, как проявляется это свойство на примере строк.

Пусть у нас будет две строки:
```python
s1 = "foo"
s2 = "bar"
```
Допишем вторую строку к первой:
```python
s1 = s1+s2
print(s1)
# foobar
```
Может показаться, что мы к существующей переменной `s1` «приклеили» справа вторую переменную — модифицировали ее. Это так, и не так одновременно. Давайте посмотрим на эти строки немного глубже. Для этого воспользуемся встроенной функцией `id()`, которая возвращает уникальный идентификатор любого объекта.
```python
s1 = "foo"
print(id(s1), s1) #проверяем идентификатор
# 139953609727144, foo

s2 = "bar"
print(id(s2), s2) #проверяем идентификатор
# 139953609727088, bar

s1 = s1+s2
print(id(s1), s1) #проверяем идентификатор
# 139953459591296, foobar
```
Как мы видим, идентификатор переменной `s1` после модификации изменился. Это означает, что старая строка `foo` была стёрта, а вместо неё записана новая, независимая от неё, строка. По «случайному» совпадению начало новой строки совпадает со старой, но с точки зрения программы **переменная `s1`  перезаписалась полностью.**

## **Преобразование типов**
```python
print(3/2)
# 1.5
```
С одной стороны, изначально мы использовали целые числа. С другой стороны, применяя к ним операцию деления, в результате получили число с плавающей точкой. В данном выражении _Python_ произвел **неявное преобразование типов**. Иными словами, во время вычисления оказалось недостаточным использование одних только целых чисел, и они были преобразованы в числа типа `float`.

```
При вычислении различных выражений Python применяет следующее правило: если в выражении встречается число с плавающей точкой или таковое получается в результате вычисления подвыражений, то результат будет представлен типом float. Такое правило существует для избежания потери данных, содержащихся в дробной части.
```

Существует также возможность явно преобразовать один тип в другой — **приведение типов.** Это осуществляется с помощью конструкции:
```python
t(var)
```
В данном выражении `var` — это объект, который подлежит преобразованию, а `t` — это тип (`int` или `float`), к которому необходимо преобразовать. Рассмотрим на примерах:
```python
print(float(1))
# 1.0
```
Аналогично преобразуются числа с плавающей точкой в целые числа:
```python
print(int(3.14))
# 3
```
Можно подумать, что преобразование из `float` в `int` будет приводить к ожидаемым результатам:
```python
print(int(2.8)) # ожидается 3, т.к. 2.8>2.5
# 2
```
Но ожидания не оправдались. Дело в том, что приведение `float` к `int` только **отбрасывает дробную часть.** Оно не действует как математическое округление.

В совокупности с неточностью чисел с плавающей точкой это может привести к совсем некорректным результатам:
```python
print(1.00+0.01-3.01) # ожидается -2.0
# -1.9999999999999998
```
Попробуем привести результат выражения к целому числу:
```python
print(int(1.00+0.01-3.01))
# -1
```
Мы хотели получить -2, а получили вообще -1! Такая особенность использования различных типов данных и преобразования между ними требует особой аккуратности. А для корректного округления чисел с плавающей точкой по всем правилам **необходимо** пользоваться функцией **`round()`**:
```python
print(round(1.00+0.01-3.01))
# -2
```
С помощью этой функции можно округлять не только до целого числа, но и до желаемого количества знаков после точки:
```python
print(3.14/2)
# 1.57
print(round(3.14/2, 1)) # второй аргумент — желаемое количество знаков
# 1.6
```

### **Преобразование строк**
```python
int_num = int(input("Введите целое число: ")) # вводим, например, 256
print(type(int_num)) # убеждаемся, что тип данных в переменной - int
# <class 'int'>
```
Аналогичное преобразование можно произвести и с числами с плавающей точкой. Главное помнить, что в Python десятичный разделитель — это именно **точка**, а не запятая, что может казаться более привычным русскоязычному пользователю.

_Python_ позволяет выполнить и обратное преобразование — из числа в строку. Пусть, например, возраст пользователя хранится как число, и мы хотим объединить в строку следующее:
```python
age = 25

my_age = "I'm " + age
# здесь возникнет ошибка
# TypeError: must be str, not int
```
Компилятор нам указывает, что мы хотим сложить строку и целое число, а это запрещено. Чтобы этот пример заработал, необходимо привести переменную `age` к строковому типу, используя функцию `str()` по аналогии с приведением численных типов:
```python
my_age = "I'm " + str(age)
print(my_age)
# I'm 25
```

### **Форматирование строк**
Удобным способом формирования строк является способ создания **форматированных строк**. В отличие от предыдущих способов, здесь не участвует явное преобразование типов, а _Python_ делает всю работу за нас, но ему всё равно нужно немного подсказывать.

Общий принцип создания форматированных строк заключается в следующем:
```
шаблон_строки % (переменные)
```
```python
age = 25
my_age = "I'm %d years old" % (age) # в шаблоне присутствует специальный символ %d
print(my_age)
# I'm 25 years old
```
Мы создали строковую переменную, в середину которой поместили число без необходимости разбивать строки на несколько и потом склеивать их. Чтобы это сделать, в шаблоне строки необходимо указывать место и тип объекта, который нужно поместить на это место, помещая специальный символ **`%d`**. Он указывает, что на этом месте должно стоять целое число (`digit`).

| **Формат**  | **Тип данных**                                                                                                                                |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `%d, %i`    | Целое число                                                                                                                                   |
| `%5d, %12d` | Выделяет пространство 5 (или любое другое число) символов под это число. Выравнивание вправо, остальное пространство остается пустым          |
| `%05d`      | Также выделяется пространство в 5 символов, но свободное пространство слева заполняется нулями                                                |
| `%o`        | Число в восьмеричной системе счисления                                                                                                        |
| `%x`        | Число в шестнадцатеричной системе счисления                                                                                                   |
| `%f`        | Число с плавающей точкой                                                                                                                      |
| `%10.2f`    | Число с плавающей точкой, для которого зарезервировано пространство из 10 символов и стоит ограничение на количество знаков после запятой — 2 |
| `%e`        | Также число с плавающей точкой, но в экспоненциальной записи                                                                                  |
| `%c`        | Код символа                                                                                                                                   |
| `%s`        | Другая строка                                                                                                                                 |
| `%%`        | Знак процента, если его необходимо использовать просто как символ в строке                                                                    |

## Изменяемые типы данных
К понятию **неизменяемость** (_unmutable_) нужно подходить правильно. Эта характеристика не подразумевает под собой некую константность данных. Строка `hello` является неизменяемой в том смысле, что любая её модификация будет порождать создание нового объекта, и в этом смысле более точный перевод _unmutable_ — немутирующий. В противоположность этому списки, словари и множества могут изменять свою структуру в существующих объектах, не порождая новые.

### **Списки**
 **Cписок** — это упорядоченный набор объектов произвольного типа.
 Создание пустого списка происходит присваиванием переменной пустых квадратных скобок:
 ```python
 s = []
```
При создании такого объекта в памяти резервируется область, в которой хранятся ссылки на элементы списка. Используя схожий синтаксис можно создать наполнение списка:
```python
s = [0, 'hello', (1, 'a')]
```
Добавление объекта осуществляется с помощью метода `append()`.

**Метод** — это функция, которая применяется к определенному объекту, используя символ точку:
```
объект.метод()
```

Список — это в первую очередь **упорядоченная** структура данных. Это означает, что каждый элемент списка имеет свой **индекс** — порядковый номер элемента в списке.

Попытка получить элемент, превышающий эту границу, вызовет ошибку, о чем _Python_ нас предупредит:
```python
print(letters[31])
# IndexError: list index out of range
```
Существует два способа. Первый — использование длины списка. Её можно узнать с помощью встроенной функции `len()`, которая возвращает длину любого итерируемого объекта. К ним относят строки, списки, кортежи и объекты некоторых других типов данных.
```python
print(len(letters)) # 5
```
Такой способ является решением «в лоб». Однако, согласно философии _Python_ _«простое лучше, чем сложное»_, поэтому есть ещё один подход соответствующий «питоновскому» стилю кода — использование отрицательных индексов:
Отрицательные индексы позволяют вывернуть наизнанку список и нумеровать его в обратном порядке. И тогда последний элемент будет иметь индекс **-1**, предпоследний — **-2** и т.д.
```python
print(letters[-1]) # g
```

Изменение структуры списка может происходить не только путем ее увеличения (добавления новых объектов), но и удаления уже существующих. Для этого можно использовать метод **`pop()`**:
```python
print(letters)
# ['a', 'b', 'c', 'd', 'e', 'f', 'g']

letters.pop() # вызов метода без аргументов удаляет последний элемент списка
print(letters)
# ['a', 'b', 'c', 'd', 'e', 'f'] 
# был удален последний элемент

letters.pop(0) # или можно удалить элемент по его индексу
print(letters)
# ['b', 'c', 'd', 'e', 'f'] 
# был удален нулевой элемент

letters.pop(3) # и не обязательно удалять из начала или конца списка
print(letters)
# ['b', 'c', 'd', 'f'] 
# был удален элемент с индексом 3
```
_Python_ не ограничивает мощь своего функционала доступом к элементам по индексам и отрицательным индексам. С помощью **срезов** можно получать сразу несколько элементов списка.

| Срез     | Как работает?                                                                                                                                                                        | **Пример**                            |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------- |
| `[:]`    | Возвращает элементы полностью                                                                                                                                                        | `[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’]` |
| `[2:]`   | Возвращает элементы списка, начиная с элемента индекса 2 и до конца списка                                                                                                           | `[‘c’, ‘d’, ‘e’, ‘f’, ‘g’]`           |
| `[:3]`   | Возвращает элементы списка от его начала до элемента с индексом 3, **не включая** его                                                                                                | `[‘a’, ‘b’, ‘c’]`                     |
| `[1:4]`  | Объединяя предыдущие два способа можно получить элементы из середины. В данном случае начиная с индекса 1 до индекса 4, не включительно. Иными словами, элементы с индексами 1,2 и 3 | `[‘b’, ‘c’, ‘d’]`                     |
| `[::2]`  | Задает шаг, через который извлекаются элементы                                                                                                                                       | `[‘a’, ‘c’, ‘e’, ‘g’]`                |
| `[::-1]` | Используя отрицательный шаг, можно развернуть массив                                                                                                                                 | `[‘g’, ‘f’, ‘e’, ‘d’, ‘c’, ‘b’, ‘a’]` |
[Методы, которые можно применять к спискам](https://pythonru.com/osnovy/spiski-python-funkcii-i-metody-python-list)

### **Словари**
**словари** (`dict`) — упорядоченные наборы объектов, доступных по ключу. Иными словами, словарь — это совокупность пар ключ-объект.

Сам объект, который хранится в словаре, может быть любым. Даже другим словарём. Но на ключи есть важное ограничение: ключ может быть только объектом неизменяемых типов данных, т.е. числом, строкой или кортежем.

Как и в случае списков, словарь можно создать пустым, можно сразу наполнить его объектами, а можно расширять постепенно:
```python
person = {} # с помощью фигурных скобок можно создать словарь

# словарь заполняется по принципу - ключ:объект (через двоеточие)
person = {'name' : 'Ivan Petrov'}

# в него можно также добавлять новые объекты по ключу
person['age'] = 25
person['email'] = 'ivan_petrov@example.com'
person['phone'] = '8(800)555-35-35'

print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com', 'phone': '8(800)555-35-35'}
```
Попытка извлечения объекта по несуществующему ключу приведет к ошибке:
```python
print(person['address'])
# KeyError: 'address'
```
Можно отдельно получить список ключей:
```python
print(person.keys())
# dict_keys(['name', 'age', 'email', 'phone'])
```
Или список значений:
```python
print(person.values())
# dict_values(['Ivan Petrov', 25, 'ivan_petrov@example.com', '8(800)555-35-35'])
```
Из словаря аналогично спискам можно удалить объект по его ключу. Словарь является упорядоченным. В функцию `pop()` всегда нужно передавать ключ удаляемого объекта:
```python
print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com', 'phone': '8(800)555-35-35'}

person.pop('phone')

print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com'}
```

### **Уникальные элементы списка**
**Множество (set)** — это неупорядоченный набор уникальных элементов. Иными словами, во множествах не могут повторяться элементы, а хранятся они в памяти компьютера в произвольном порядке.

Создать множество можно несколькими способами:
```python
a = {'a', 'b', 'c', 'd'} # используя синтаксис { }
```
Или, что нам будет более полезно, множество можно создать из списка с помощью приведения типов:
```python
L = [1,1,2,3,2]

b = set(L)

print(b)
# {1,2,3}
```

| Операция                          | Название              | Смысл                                                                                                       |
| --------------------------------- | --------------------- | ----------------------------------------------------------------------------------------------------------- |
| `set.union(other)`                | Объединение           | Возвращает множество, состоящее из элементов `set` и `other`.                                               |
| `set.intersection(other)`         | Пересечение           | Возвращает множество элементов `set`, которые не встречаются в `other`.                                     |
| `set.difference(other)`           | Разность              | Возвращает множество элементов `set`, которые не встречаются в `other`.                                     |
| `set.symmetric_difference(other)` | Симметричная разность | Возвращает множество, включающее все элементы исходных множеств, которые не принадлежат обоим одновременно. |

### Идентичность
Встроенная функция `id()` позволяет получить число, которое называется идентичностью. Каждый объект при создании получает некоторое значение идентичности, и оно не может измениться у одного конкретного объекта во время выполнения программы. Также можно сказать, что это число ассоциируется с адресом области памяти компьютера, в которой хранится данный объект.

Предположим, что у нас есть две переменные:
```python
a = 5
b = 3+2
```
Каждая из них имеет значение равное 5, но создаются они совершенно разным образом. Первая — прямым присваиванием числа 5, вторая — как результат арифметической операции над другими числами-объектами. Их id будут одинаковыми.
Некоторые целые числа и строки **кэшируются** в памяти, позволяя не создавать каждый раз новый объект. Иными словами, _Python_ при компиляции сам создает объекты некоторых видов и сохраняет их в памяти. И если в коде встречается «создание» такого объекта, то он подгружается из этой временной памяти.

Рассмотренное нами свойство уникальности каждого объекта используется, в том числе для сравнения объектов с помощью ключевого слова `is`.
```python
list_1 = ['a', 'b', 'c']
list_2 = list_1
list_3 = list(list_1)
print(list_1)
print(list_2)
print(list_3)

['a', 'b', 'c']
['a', 'b', 'c']
['a', 'b', 'c']

print(list_1 == list_2) # True
print(list_1 == list_3) # True

print(list_1 is list_2) # True
print(list_1 is list_3) # False
```
Здесь мы можем увидеть `(list_1 is list_3) False`, потому что `list_1` и `list_3` указывают на два разных объекта, даже если их содержимое может быть одинаковым. Таким образом, мы можем сказать, что `«is»` вернет True, если две переменные указывают на один и тот же объект, и `«==»`, если объекты, на которые ссылаются переменные, равны.

Как уже упоминалось ранее, эту особенность стоит учитывать при работе со списками. 
При работе со списками есть особенность, которую необходимо рассмотреть.
```python
L = ['Hello', 'world']
M = L

print(M is L) # True
```
Очевидно, что эти списки будут равны по своим значениям (сравнивая через `==`). И при таком присваивании в `M` скопируется не сам список `L`, а его идентификатор! Поэтому, изменяя список `M`, мы увидим неожиданные изменения в списке `L`.
```python
M.append('!')
print(L)
# ['Hello', 'world', '!']
```
Чтобы избежать такого поворота событий, список нужно **копировать**.
```python
M = L.copy()
print(M is L)
# False
```

### **Неизменяемость кортежей**
 К элементам кортежа также можно обратиться по индексам, однако он является неизменяемым. После создания он «замораживается» и добавить или удалить элементы становится невозможно.
Однако здесь есть небольшой нюанс. Неизменяемость кортежей заключается в неизменности набора уникальных идентификаторов объектов, которые хранятся в кортеже. Эту небольшую «лазейку» можно использовать в практических целях.

Например, мы хотим хранить в кортеже информацию о торгово-развлекательном центре: его название, адрес и список магазинов. В общем-то такой набор информации остается почти всегда неизменным за исключением того, что список магазинов может изменяться — какие-то закрываются, какие-то открываются или же меняют название. По этой причине такой список нельзя хранить в самом кортеже. Однако можно создать список (`list`) внутри самого кортежа.

```python
shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])

shopping_center[-1].append("Uniqlo")

print(shopping_center)
# ('Галерея', 'Санкт-Петербург', 'Лиговский пр., 30', ['H&M', 'Zara', 'Uniqlo'])
```
Как видим, изменение списка внутри кортежа не привело к ошибке, потому что уникальный идентификатор этого списка остался неизменным. Можно убедиться в этом самостоятельно.