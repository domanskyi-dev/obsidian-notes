## test_Работа с файлами

## **1. Основные операции с файлами**

### **1.1 Открытие и закрытие файлов**

**Синтаксис:**
```python
file = open("file.txt", "r")  # Открытие файла
content = file.read()         # Чтение содержимого
file.close()                  # Закрытие файла (обязательно!)
```
**Проблема:** Если произойдёт ошибка между `open()` и `close()`, файл останется открытым.  
**Решение:** Контекстный менеджер (`with`):
```python
with open("file.txt", "r") as file:  # Автоматически закрывает файл
    content = file.read()
```

### **1.2 Режимы открытия файлов**

|Режим|Описание|
|---|---|
|`"r"`|Чтение (по умолчанию). Ошибка, если файл не существует.|
|`"w"`|Запись. Перезаписывает файл, если он существует. Создаёт, если нет.|
|`"a"`|Дозапись в конец файла. Создаёт файл, если нет.|
|`"x"`|Эксклюзивное создание. Ошибка, если файл существует.|
|`"b"`|Бинарный режим (например, `"rb"` или `"wb"`).|
|`"+"`|Открытие для чтения и записи (`"r+"`, `"w+"`).|

**Примеры:**
```python
with open("data.txt", "w") as f:
    f.write("Hello, World!")  # Запись строки

with open("data.txt", "a") as f:
    f.write("\nNew line")     # Дозапись
```

## **2. Чтение из файла**

### **2.1 Методы чтения**

|Метод|Описание|
|---|---|
|`.read()`|Читает весь файл в строку (или байты в бинарном режиме).|
|`.readline()`|Читает одну строку (с символами `\n`).|
|`.readlines()`|Читает все строки в список.|
|Итерация|Чтение файла построчно (эффективно по памяти).|

**Примеры:**
```python
# Чтение всего файла
with open("file.txt") as f:
    content = f.read()

# Чтение построчно
with open("file.txt") as f:
    for line in f:          # Ленивое чтение (не грузит весь файл в память)
        print(line.strip())  # Удаляем \n в конце строки

# Чтение в список строк
with open("file.txt") as f:
    lines = f.readlines()  # ["line1\n", "line2\n"]
```

### **2.2 Чтение больших файлов**

**Проблема:** Файлы размером >1 ГБ могут не поместиться в оперативную память.  
**Решение:** Читать по частям или построчно.

**Вариант 1:** Чтение блоками (например, по 1024 байта):
```python
with open("huge_file.txt", "rb") as f:
    while True:
        chunk = f.read(1024)  # Читает 1024 байта
        if not chunk:
            break
        process(chunk)
```
**Вариант 2:** Построчное чтение:
```python
with open("huge_file.txt") as f:
    for line in f:  # Читает по одной строке
        process(line)
```

## **3. Запись в файл**

### **3.1 Основные методы**

|Метод|Описание|
|---|---|
|`.write(text)`|Записывает строку (или байты) в файл.|
|`.writelines()`|Записывает список строк (без автоматических `\n`!).|

**Примеры:**
```python
# Запись строки
with open("output.txt", "w") as f:
    f.write("Hello\nWorld!")  # \n для переноса строки

# Запись списка строк
lines = ["line1\n", "line2\n"]
with open("output.txt", "w") as f:
    f.writelines(lines)  # Не добавляет \n автоматически!
```

### **3.2 Безопасная запись**

**Проблема:** Если скрипт упадёт во время записи, файл может повредиться.  
**Решение:**
1. Писать во временный файл.
2. Переименовывать его после успешной записи.
```python
import os

def safe_write(filename, data):
    temp_file = f"{filename}.tmp"
    with open(temp_file, "w") as f:
        f.write(data)
    os.replace(temp_file, filename)  # Атомарная операция
```

## **4. Бинарные файлы**

### **4.1 Чтение/запись байтов**

Используется режим `"b"` (например, для изображений, PDF и т. д.):
```python
# Копирование файла
with open("image.jpg", "rb") as src, open("copy.jpg", "wb") as dst:
    dst.write(src.read())
```

### **4.2 Работа с `struct`**

Для чтения/записи структур данных (например, заголовков файлов):
```python
import struct

# Запись числа int в бинарном виде
with open("data.bin", "wb") as f:
    f.write(struct.pack("i", 123))  # 'i' — формат int (4 байта)

# Чтение
with open("data.bin", "rb") as f:
    num = struct.unpack("i", f.read(4))[0]  # (123,)
```

## **5. Кодировки файлов**

### **5.1 Указание кодировки**

По умолчанию используется `utf-8`, но можно задать явно:
```python
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()
```

**Популярные кодировки:**

- `utf-8` (Unicode)
- `cp1251` (Windows-1251 для русского)
- `ascii` (только английские символы)

### **5.2 Обработка ошибок кодировки**
```python
with open("file.txt", "r", encoding="utf-8", errors="ignore") as f:
    content = f.read()  # Пропустит нечитаемые символы
```
**Варианты `errors`:**
- `ignore` — пропустить неверные символы.
- `replace` — заменить их на `�`.
- `strict` (по умолчанию) — вызвать `UnicodeDecodeError`.

## **6. Работа с файловой системой**

### **6.1 Модуль `os`**

```python
import os

os.mkdir("folder")          # Создать папку
os.listdir(".")             # Список файлов в директории
os.path.exists("file.txt")  # Проверить существование файла
os.remove("file.txt")       # Удалить файл
```
### **6.2 Модуль `shutil`**

Для сложных операций (копирование, перемещение):
```python
import shutil

shutil.copy("src.txt", "dst.txt")  # Копирование файла
shutil.rmtree("folder")            # Удаление папки рекурсивно
```

## **7. Вопросы с собеседований**

### **Вопрос 1: Как прочитать файл задом наперёд?**

**Ответ:**
```python
with open("file.txt") as f:
    for line in reversed(f.readlines()):  # Для небольших файлов
        print(line.strip())
```

Для больших файлов — читать с конца блоками.

### **Вопрос 2: Как безопасно удалить файл?**

**Ответ:**

1. Проверить существование:
```python
if os.path.exists("file.txt"):
    os.remove("file.txt")
```
2. Использовать `try-except`:
```python
try:
    os.remove("file.txt")
except FileNotFoundError:
    pass
```

### **Вопрос 3: Как записать JSON в файл?**

**Ответ:**
```python
import json

data = {"name": "Alice", "age": 30}
with open("data.json", "w") as f:
    json.dump(data, f, indent=4)  # indent для красивого форматирования
```

## **8. Практические задачи**

**Задача 1:** Написать функцию для подсчёта строк в файле.
```python
def count_lines(filename):
    with open(filename) as f:
        return sum(1 for _ in f)
```

**Задача 2:** Реализовать аналог `grep` (поиск строки в файле).
```python
def grep(filename, pattern):
    with open(filename) as f:
        for line in f:
            if pattern in line:
                print(line.strip())
```

## **Итог**

- **Контекстные менеджеры (`with`)** — безопасное открытие/закрытие.
- **Режимы работы** (`r`, `w`, `a`, `b`) — ключевые для разных задач.
- **Кодировки** — всегда указывать явно (`utf-8`).
- **Бинарные файлы** — работают через `"rb"`/`"wb"`.
- **Безопасность** — временные файлы и обработка ошибок.

