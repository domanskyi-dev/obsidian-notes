## **1. Переменные и типы данных**

### **Динамическая типизация**

Python — язык с динамической типизацией: тип переменной определяется в runtime.
```python
x = 10      # int
x = "hello" # str (тип меняется)
```
### **Основные типы данных**

|Тип|Пример|Изменяемость|
|---|---|---|
|`int`|`42`|Неизменяемый|
|`float`|`3.14`|Неизменяемый|
|`str`|`"Python"`|Неизменяемый|
|`bool`|`True`|Неизменяемый|
|`list`|`[1, 2, 3]`|Изменяемый|
|`tuple`|`(1, 2)`|Неизменяемый|
|`dict`|`{"key": 42}`|Изменяемый|
|`set`|`{1, 2, 3}`|Изменяемый|

**Важно:**

- Изменяемые типы нельзя использовать как ключи словаря (`dict`).

- `tuple` неизменяем, но может содержать изменяемые элементы (например, список):
```python
t = (1, [2, 3])  # Кортеж с изменяемым списком внутри
t[1].append(4)   # ОК: список меняется
t[1] = [5]       # Ошибка: кортеж неизменяем
```
## **2. Операции и сравнения**

### **Арифметические операции**

```python
5 / 2    # 2.5 (деление с float)
5 // 2   # 2 (целочисленное деление)
5 % 2    # 1 (остаток)
2 ** 3   # 8 (степень)
```

### **Сравнение объектов**
- `==` — проверка значений.
- `is` — проверка идентичности (тот же объект в памяти).
```python
a = [1, 2]
b = [1, 2]
a == b  # True (значения одинаковы)
a is b  # False (разные объекты)
```

**Особенность с `None`, `True`, `False`:**
```python
x = None
x is None  # True (правильный стиль, а не == )
```

## **3. Управляющие конструкции**

### **Условия (`if-elif-else`)**
```python
if x > 0:
    print("Positive")
elif x == 0:
    print("Zero")
else:
    print("Negative")
```
**Тернарный оператор:**
```python
result = "Even" if x % 2 == 0 else "Odd"
```
### **Циклы (`for`, `while`)**

**`for`:** Итерируется по коллекциям.
```python
for i in range(3):       # 0, 1, 2
    print(i)

for char in "abc":       # 'a', 'b', 'c'
    print(char)
```
**`while`:** Выполняется, пока условие истинно.
```python
while x > 0:
    print(x)
    x -= 1
```
**Контроль цикла:**
- `break` — выход из цикла.
- `continue` — переход к следующей итерации.

## **4. Функции**

### **Объявление и вызов**
```python
def greet(name):
    return f"Hello, {name}!"

greet("Alice")  # "Hello, Alice!"
```
### **Параметры и аргументы**

- **Позиционные аргументы:** `func(1, 2)`
- **Именованные аргументы:** `func(x=1, y=2)`
- **Аргументы по умолчанию:**
```python
def pow(x, power=2):
    return x ** power
```
**Важно:** Изменяемые объекты (например, списки) в аргументах по умолчанию — опасны!
```python
def bad_idea(a=[]):  # Все вызовы используют один и тот же список!
    a.append(1)
    return a
```
### **`*args` и `**kwargs`**

- `*args` — кортеж позиционных аргументов.
- `**kwargs` — словарь именованных аргументов.
```python
def sum_all(*args):
    return sum(args)

sum_all(1, 2, 3)  # 6
```

## **5. Работа с коллекциями**

### **Списки (`list`)**

**Основные операции:**
```python
nums = [1, 2, 3]
nums.append(4)    # [1, 2, 3, 4]
nums.insert(1, 5) # [1, 5, 2, 3, 4]
nums.pop()        # Удаляет последний элемент (4)
```
**Срезы (slicing):**
```python
nums = [0, 1, 2, 3, 4]
nums[1:3]    # [1, 2] (индексы 1 и 2)
nums[::2]    # [0, 2, 4] (каждый второй)
nums[::-1]   # [4, 3, 2, 1, 0] (реверс)
```

### **Словари (`dict`)**
```python
data = {"name": "Alice", "age": 30}
data["name"]          # "Alice"
data.get("name")      # "Alice" (без KeyError)
data.get("job", "N/A") # "N/A" (значение по умолчанию)
```
**Итерация по словарю:**
```python
for key in data:          # Ключи
for value in data.values(): # Значения
for key, value in data.items(): # Пары
```

## **6. ООП (Классы и объекты)**
### **Базовый пример**
```python
class Dog:
    def __init__(self, name):
        self.name = name  # Поле экземпляра

    def bark(self):
        return f"{self.name} says Woof!"

dog = Dog("Rex")
dog.bark()  # "Rex says Woof!"
```

### **Наследование**
```python
class Bulldog(Dog):
    def bark(self):
        return f"{self.name} says Grrr!"  # Переопределение метода
```

### **Инкапсуляция**
- **Публичные атрибуты:** `self.name`
- **Приватные атрибуты (условно):** `self._hidden` (по соглашению)
- **"Защищённые" атрибуты:** `self.__very_hidden` (name mangling)

## **7. Исключения**

### **Обработка ошибок**

```python
try:
    x = 1 / 0
except ZeroDivisionError:
    print("Нельзя делить на ноль!")
except Exception as e:
    print(f"Ошибка: {e}")
else:
    print("Всё ок!")
finally:
    print("Это выполнится всегда.")
```

**Свои исключения:**
```python
class MyError(Exception):
    pass

raise MyError("Что-то пошло не так!")
```

## **8. Работа с файлами**

### **Чтение и запись**

```python
# Запись
with open("file.txt", "w") as f:
    f.write("Hello\nWorld")

# Чтение
with open("file.txt") as f:
    lines = f.readlines()  # ["Hello\n", "World"]
```

**Режимы открытия файла:**
- `"r"` — чтение (по умолчанию).
- `"w"` — перезапись (удаляет старый файл!).
- `"a"` — дозапись в конец.
- `"rb"`/`"wb"` — бинарный режим.

## **Практические задачи для закрепления**

1. **Функция, которая возвращает список без дубликатов:**
```python
def remove_duplicates(lst):
    return list(set(lst))
```
2. **Подсчёт слов в строке:**
```python
def word_count(s):
    return len(s.split())
```
3. **Проверка на палиндром:**
```python
def is_palindrome(s):
    return s == s[::-1]
```

## **Частые вопросы на собеседованиях**
1. **Чем список отличается от кортежа?**  
    → Список изменяем, кортеж — нет. Кортеж быстрее и занимает меньше памяти.
2. **Как передаются аргументы в функции: по значению или по ссылке?**  
    → В Python всё передаётся **по присваиванию** (передача ссылки на объект).
3. **Что такое mutable и immutable типы?**  
    → Изменяемые (`list`, `dict`, `set`) vs неизменяемые (`int`, `str`, `tuple`).
4. **Как работает `is`?**  
    → Проверяет, ссылаются ли переменные на один и тот же объект в памяти.

### **Вопрос 1: Что такое динамическая типизация?**

**Ответ:**  
Python определяет тип переменной во время выполнения (runtime), а не на этапе компиляции.

**Контрольный вопрос:**  
_Почему это может быть проблемой?_  
→ Ошибки типов могут всплыть только при выполнении (например, сложение строки и числа).

### **Вопрос 2: Как работает оператор `is`? Чем отличается от `==`?**
**Ответ:**
- `is` проверяет, ссылаются ли переменные на **один и тот же объект в памяти**.
- `==` сравнивает **значения**.

### **Вопрос 3: Когда использовать `list`, а когда `tuple`?**
**Ответ:**
- **`list`**: Если нужно изменять содержимое (добавлять/удалять элементы).
- **`tuple`**: Если данные неизменны (например, ключи в словаре).

### **Вопрос 4: Как устроен словарь (`dict`) в Python?**

**Ответ:**  
Словарь — это **хеш-таблица**:
- Ключи должны быть **хешируемыми** (неизменяемые типы: `int`, `str`, `tuple`).
- При коллизиях используется **открытая адресация**.

**Пример вопроса:**  
_Что быстрее: `if key in dict` или `if key in list`?_  
→ `if key in dict` — O(1), а в списке — O(n).

### **Вопрос 5: Что такое `*args` и `**kwargs`?**

**Ответ:**
- `*args` — собирает позиционные аргументы в **кортеж**.
- `**kwargs` — собирает именованные аргументы в **словарь**.

```python
def func(*args, **kwargs):
    print(args)  # (1, 2)
    print(kwargs) # {"x": 3}

func(1, 2, x=3)
```

**Когда использовать:**  
Для создания универсальных функций (например, декораторов).

### **Вопрос 6: В чём разница между `@classmethod` и `@staticmethod`?**

**Ответ:**

- **`@classmethod`**: Получает класс (`cls`) как первый аргумент. Может менять состояние класса.
- **`@staticmethod`**: Не получает ни `self`, ни `cls`. Это просто функция внутри класса.

**Пример:**
```python
class MyClass:
    @classmethod
    def from_string(cls, s):
        return cls(int(s))  # Альтернативный конструктор

    @staticmethod
    def is_positive(x):
        return x > 0
```

### **Вопрос 7: Как правильно обрабатывать исключения?**

**Ответ:**  
Использовать конкретные исключения, а не общие `Exception`:
```python
try:
    with open("file.txt") as f:
        data = f.read()
except FileNotFoundError:
    print("Файл не найден!")
except IOError as e:
    print(f"Ошибка ввода-вывода: {e}")
```

**Контрольный вопрос:**  
_Почему `except:` без указания типа — плохая практика?_  
→ Перехватывает даже `KeyboardInterrupt` и `SystemExit`.

### **Вопрос 8: Как прочитать большой файл без нагрузки на память?**

**Ответ:**  
Использовать **генератор** или построчное чтение:
```python
with open("huge_file.txt") as f:
    for line in f:  # Читает по одной строке
        process(line)
```
**Альтернатива:**
```python
def read_in_chunks(file, chunk_size=1024):
    while True:
        data = file.read(chunk_size)
        if not data:
            break
        yield data
```

### **Вопрос 9: Что такое GIL? Как он влияет на многопоточность?**

**Ответ:**  
**GIL (Global Interpreter Lock)** — это мьютекс, который позволяет выполняться только одному потоку Python за раз.

- **Проблема**: Многопоточные CPU-задачи не ускоряются.
- **Решение**: Использовать `multiprocessing` или `asyncio` для I/O-задач.

**Пример:**
```python
from threading import Thread
import time

def task():
    time.sleep(1)  # I/O-операция

# Запуск потоков
t1 = Thread(target=task)
t2 = Thread(target=task)
t1.start(); t2.start()
```

### **Вопрос 10: Чем `asyncio` отличается от `threading`?**

**Ответ:**

|`asyncio`|`threading`|
|---|---|
|Однопоточный|Многопоточный|
|Использует корутины|Использует потоки|
|Подходит для I/O-задач|Есть GIL (CPU-задачи — нет)|

**Пример `asyncio`:**
```python
import asyncio

async def fetch_data():
    await asyncio.sleep(1)  # Неблокирующий sleep
    return "Data"

async def main():
    result = await fetch_data()
    print(result)

asyncio.run(main())
```

### **Вопрос 11: Как написать декоратор для замера времени выполнения функции?**

**Ответ:**
```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"Time: {time.time() - start:.2f}s")
        return result
    return wrapper

@timer
def slow_func():
    time.sleep(1)

slow_func()  # Выведет: "Time: 1.00s"
```

### **Вопрос 12: Что такое генераторы? Зачем они нужны?**

**Ответ:**  
Генераторы — это функции с `yield`, которые возвращают итератор.  
**Плюсы:**
- Ленивые вычисления (экономят память).
- Можно обрабатывать бесконечные последовательности.

**Пример:**
```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

gen = fibonacci()
print(next(gen))  # 0
print(next(gen))  # 1
```

## **Web3/Blockchain **
### **Вопрос 13: Что такое смарт-контракт?**

**Ответ:**  
Это программа на блокчейне (например, Ethereum), которая выполняется при выполнении условий. Пишется на **Solidity**, а взаимодействовать с ним можно через **Web3.py**:
```python
from web3 import Web3

w3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io"))
contract_address = "0x..."
contract = w3.eth.contract(address=contract_address, abi=abi)
balance = contract.functions.balanceOf("0x...").call()
```
